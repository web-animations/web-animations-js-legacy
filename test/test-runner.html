<!--
@license Copyright 2012 Google Inc. All Rights Reserved.

vim: set ts=2 sw=2 et sts=2 ai:

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!DOCTYPE html>
<style>
h1 {
  display: inline;
}

table {
  border-collapse:collapse;
}

td {
  border: 1px solid black;
}

iframe {
  width: 800px;
  height: 600px;
}

tbody {
  color: gray;
}

/* Pass styles */
tbody.pass {
  color: green;
}

li.pass {
  color: green;
}


/* Pass styles */
tbody.no-tests {
  color: #ff8a00;
}

/* Fail styles */
tbody.fail {
  color: red;
}

li.fail {
  color: red;
}

</style>
<script src="testcases.js"></script>

<h1 id=status>Pending</h1>
Loading: <span id=loading></span>
Unstarted: <span id=unstarted></span>
Running: <span id=running></span>
Posting: <span id=posting></span>
Finished: <span id=finished></span>

<table id="results"></table>

<script>

(function() {
window.finished = false;

/**
 * Get the most accurate version of time possible.
 *
 * @return {number} Time as this very moment.
 */
function now() {
  if (window.performance && window.performance.now) return window.performance.now();
  return Date.now();
}

/**
 * Creates HTML elements in a table for a test.
 *
 * +-----------+------+-------+
 * | Test Name | Link | Count |
 * +-----------+------+-------+
 * | Log of test run.         |
 * +--------------------------+
 * | iFrame containing test   |
 * +--------------------------+
 *
 * @param {String} testName Name of the test suite being run.
 * @param {String} testURL The url of the test suite.
 * @return {Element} tbody containing newly created table rows.
 */
function createTestRows(testName, testURL) {
  var tablegroup = document.createElement("tbody");
  tablegroup.id = testName;

  var basicInfoRow = document.createElement("tr");
  tablegroup.appendChild(basicInfoRow);
  var logRow = document.createElement("tr");
  tablegroup.appendChild(logRow);
  var iframeRow = document.createElement("tr");
  tablegroup.appendChild(iframeRow);

  // Name
  var header = document.createElement("h1");
  header.textContent = testName;

  var headerCell = document.createElement("td");
  headerCell.appendChild(header);
  basicInfoRow.appendChild(headerCell);

  // Link
  var link = document.createElement("a");
  link.textContent = testName;
  link.href = testURL;

  var linkCell = document.createElement("td");
  linkCell.appendChild(link);
  basicInfoRow.appendChild(linkCell);

  // Test count
  var countCell = document.createElement("td");
  countCell.className = "count";
  basicInfoRow.appendChild(countCell);

  // Timing info
  var timingCell = document.createElement("td");
  timingCell.className = "timing";
  basicInfoRow.appendChild(timingCell);

  // table row containing the complete test log
  var logCell = document.createElement("td");
  logCell.className = "log";
  logCell.colSpan = "4";
  logRow.appendChild(logCell);

  // iframe containing a preview of object
  var iframe = document.createElement("iframe");
  iframe.src = testURL;

  var iframeCell = document.createElement("td");
  iframeCell.colSpan = "4";
  iframeCell.appendChild(iframe);
  iframeRow.appendChild(iframeCell);

  basicInfoRow.onclick = function() {
    if (logRow.style.display == "none") {
      logRow.style.display = "table-row";
      iframeRow.style.display = "table-row";
    } else {
      logRow.style.display = "none";
      iframeRow.style.display = "none";
    }
  };
  basicInfoRow.click();
  return tablegroup;
}

/**
 * Called when a test is started.
 * @param {Element} test dom object representing the test. id will contain the
 *    test name.
 */
function testStarted(test) {
  test.start = now();
}

/**
 * Called when a test is finished.
 * @param {object} test dom object representing the test. id will contain the
 *    test name.
 */
function testFinished(test) {
  test.finished = now();
  test.querySelector(".timing").innerText = (test.finished - test.start).toFixed(2) + "ms";
}

/* @type {?number} */ var intervalId = null;

/**
 * Checks all the tests are in the unstarted state and then kicks of running
 * the tests.
 */
function haveAllTestsLoaded() {
  if (loadingTests.length != 0)
    return;

  intervalId = window.setInterval(runTests, 10);
}

/**
 * Checks all the tests are in the finished state and then marks the whole test
 * as finished and stops the periodic javascript functions.
 */
function haveAllTestsFinished() {
  if (finishedTests.length != tests.length)
    return;

  window.clearInterval(intervalId);
  window.finished = true;
}


/**
 * These lists show track which state a test is in. An individual test should
 * only ever be in one of the lists. You use the changeTestState() function to
 * move from one state to another.
 *
 * Tests start off in the loading state, the move downwards until ending up in
 * the finished state.
 */
/* @type {Array.<Element>} */ var loadingTests = [];
/* @type {Array.<Element>} */ var unstartedTests = [];
/* @type {Array.<Element>} */ var runningTests = [];
/* @type {Array.<Element>} */ var postingTests = [];
/* @type {Array.<Element>} */ var finishedTests = [];

/**
 * Enum for state values.
 * @enum {number}
 */
var States = {
  LOADING: 1,    /* Test which is being loaded. */
  UNSTARTED: 2,  /* Test which have yet to start. */
  RUNNING: 3,    /* Test that is currently running. */
  POSTING: 4,    /* Test that is currently posting results to server. */
  FINISHED: 5,   /* Test which has completed. */
};

/**
 * Changes the state of the given test to the given state.
 * This function doesn't check that the state transition actually make sense.
 *
 * @param {Element} test DOM object representing the test. The id will contain
 *     the test name.
 * @param {States} The new state to transition too.
 */
function changeTestState(test, newState) {
  var i = null;

  // Remove the test object form all the queues.
  i = loadingTests.indexOf(test);
  if (i >= 0) {
    loadingTests.splice(i, 1);
  }
  i = unstartedTests.indexOf(test);
  if (i >= 0) {
    unstartedTests.splice(i, 1);
  }
  i = runningTests.indexOf(test);
  if (i >= 0) {
    runningTests.splice(i, 1);
    testFinished(test);
  }
  i = postingTests.indexOf(test);
  if (i >= 0) {
    postingTests.splice(i, 1);
  }

  switch(newState) {
  case States.LOADING:
    loadingTests.unshift(test);
    haveAllTestsLoaded();
    break;
  case States.UNSTARTED:
    unstartedTests.unshift(test);
    break;
  case States.RUNNING:
    testStarted(test);
    runningTests.unshift(test);
    break;
  case States.POSTING:
    postingTests.unshift(test);
    break;
  case States.FINISHED:
    finishedTests.unshift(test);
    haveAllTestsFinished();
    break;
  }
}


/**
 * Elements for reporting the overall status.
 */
/* @type {Element} */ var statusElement = document.querySelector("#status");
/* @type {Element} */ var loadingElement = document.querySelector("#loading");
/* @type {Element} */ var unstartedElement = document.querySelector("#unstarted");
/* @type {Element} */ var runningElement = document.querySelector("#running");
/* @type {Element} */ var postingElement = document.querySelector("#posting");
/* @type {Element} */ var finishedElement = document.querySelector("#finished");

/* @type {?number} */ var statusIntervalId = null;

/**
 * Update the status dialog with information about the current status.
 */
function updateStatus() {
  loadingElement.innerText = loadingTests.length;
  unstartedElement.innerText = unstartedTests.length;
  runningElement.innerText = runningTests.length;
  postingElement.innerText = postingTests.length;
  finishedElement.innerText = finishedTests.length;

  if (loadingElement.length > 0) {
    statusElement.innerText = "Loading";
  } else if (runningTests.length > 0) {
    statusElement.innerText = "Running";
  } else if (postingTests.length > 0) {
    statusElement.innerText = "Posting results";
  } else if (finishedTests.length == tests.length) {
    statusElement.innerText = "Finished";
    window.clearInterval(statusIntervalId);
  }
}


/**
 * Create the iframes for each test.
 */
window.onload = function createTestRunners() {
  statusIntervalId = window.setInterval(updateStatus, 10);

  for (var i = 0; i < tests.length; i++) {
    var testName = tests[i];
    var testURL = "testcases/" + testName;

    var test = createTestRows(testName, testURL);
    changeTestState(test, States.LOADING);

    document.querySelector("#results").appendChild(test);
    test.querySelector("iframe").contentWindow.onload = function() {
      changeTestState(this, States.UNSTARTED);
      haveAllTestsLoaded();
    }.bind(test);

  }
}

var maxParallel = 1;

/**
 * Start as many unstarted tests as possible, wait for results and then post
 * them.
 */
function runTests() {

  // Start as many unstarted tests as possible
  while (unstartedTests.length > 0 && runningTests.length < maxParallel) {
    // Move from unstarted to running state
    var test = unstartedTests[0];

    var testWindow = test.querySelector("iframe").contentWindow;
    testWindow.setTimeout(testWindow.animTestRunner.start, 1);

    changeTestState(test, States.RUNNING);
  }

  // Get the results from finished tests and post them.
  for (var i = 0; i < runningTests.length; i++) {
    var test = runningTests[i];

    var testWindow = test.querySelector("iframe").contentWindow;
    if (!testWindow.animTestRunner || !testWindow.animTestRunner.results)
      continue;

    var result = processResults(test, testWindow.animTestRunner.results);
    if (result) {
      // Move from running to posting state
      changeTestState(test, States.POSTING);
      i--;

      var data = new FormData();
      data.append("data", JSON.stringify(result));

      var xhr = new XMLHttpRequest();
      xhr.onload = function () {
        // Move from running to finished state
        changeTestState(this, States.FINISHED);
      }.bind(test);
      xhr.open("POST", "test-results-post.html", true);
      xhr.send(data);
    } else {
      // Move directly to finished state
      changeTestState(test, States.FINISHED);
      i--;
    }

  }
}

/**
 * Processes the test's results and put the information into the test object.
 *
 * @param {Element} test DOM object representing the test.
 */
function processResults(test, results) {
  var logElement = test.querySelector(".log");

  var newResultsDiv = document.createElement('ul');
  for (var x in results){
    var output = document.createElement('li');
    output.innerHTML += results[x].name + " ";

    var grade = 'fail';
    if (results[x].status == 0) {
      grade = "pass";
    }
    output.className = grade;

    output.innerHTML += grade + " ";
    if (results[x].message != null) {
      output.innerHTML += results[x].message;
    }
    newResultsDiv.appendChild(output);
  }
  logElement.appendChild(newResultsDiv);

  if (results.length > 0) {
    var testResult = {};
    testResult["type"] = "result";
    testResult["testName"] = test.id;
    testResult["results"] = results;

    var passed = results.filter(function(result) {
        return result.status == 0;
      }).length;
    var failed = results.length - passed;

    if (!failed) {
      test.className = "pass";
    } else {
      test.className = "fail";
    }

    var count = test.querySelector(".count");
    count.innerText = passed + " of " + results.length + " passed";

    var log = test.querySelector(".log");
    return testResult;
  } else {
    test.className = "no-tests";
  }
}

})();
</script>
